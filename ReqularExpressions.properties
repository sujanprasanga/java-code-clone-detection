
returnType=[\\w\\[\\]<>\\.$ ,]+[ ]

methodNameAndParam=[\\w$]+\\([\\w\\[\\]<>\\.$ ,]*\\)( throws [\\w\\. ,]+)?;

allAccessMods=((public )|(private )|(protected ))?(static )?(abstract )?(final )?(synchronized )?(native )?


accessibleMods=public (static )?(final )?

abstract=((public )|(private )|(protected ))?(static )?abstract (final )?(synchronized )?
native=((public )|(private )|(protected ))?(static )?(final )?(synchronized )?native[ ]

invoke=(?<label>\\d+): (?<op>invoke)((interface)|(static)|(virtual)|(special)) +#\\d+(, +\\d+)? +\\/\\/ (Interface)?Method ((?<type>[\\"\\w/$\\[;]+)\\.)?(?<method>[\\w$\\"\\<\\"\\>]+:\\([\\w/\\.;$\\[]*\\)[\\w$/\\.;\\[]+)


invokeDynamic=(?<label>\\d+): invokedynamic #\\d+, +\\d+

fieldOp=(?<label>\\d+): (?<op>(get)|(put))((static)|(field)) +#\\d+ +// Field [\\w$\\.\\/]+:(?<fieldSignature>[\\w/$;\\[]+)

primitiveOp=(?<label>\\d+): (?<type>[ailfdsbc])(?<arrayOp>a?)(?<op>((const(_null)?)|(store)|(load)|(add)|(2[fildbcs])|(mul)|(div)|(sub)|(and)|(x?or)|(u?sh[lr])|(rem)|(neg)|(cmp[gl]?)))

newArray=(?<label>\\d+): (multi)?a?newarray +((#\\d+)|(?<primitivetype>\\w+))( +// class \\"?(?<type>[\\[\\w/;$]+)\\"?)?

conditionals=(?<label>\\d+): (?<op>(goto(_w)?)|(if(_[ai]cmp)?((eq)|(ge)|(gt)|(le)|(lt)|(ne)|(nonnull)|(null)))) +(?<target>\\d+)


other=(?<label>\\d+): (?<op>(dup2?_?x?[12]?)|(monitore((nter)|(xit)))|(iinc)|(arraylength)|(athrow)|(jsr(_w)?)|(ldc2?(_w)?)|(pop2?)|(nop)|(swap)|(wide)|([bs]ipush)|(ret ))( +.+)?

instanceOp=(?<label>\\d+): (?<op>(checkcast)|(instanceof)|(new)) +#\\d+ +// class \\"?(?<type>[\\w/$\\[]+)

return=(?<label>\\d+): [a-z]?(?<op>return)

switch=(?<label>\\d+): ((table)|(lookup))switch +\\{(?<targets> \\/\\/ \\-?\\d+( to \\-?\\d+)?([\\r\\n ]+([\\-\\d: \\r\\n]+))default: (\\d+)[\\r\\n ]+)}
switchTargets=[ ]+(\\d+|(default)): (?<target>\\d+)\\r

instructionSplitter=(\\d+: [\\w \\d#/$\\.\\"\\<\\>:\\(;\\,)\\[]+\\r)|(\\d+: \\w+ +\\{ // [\\-\\w \\r\\n:]+\\}\\r)|(\\d+: ldc +#\\d+ +\\/\\/ String .+)



